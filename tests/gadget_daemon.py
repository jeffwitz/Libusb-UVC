#!/usr/bin/env python3
"""User-space USB gadget daemon backed by :mod:`tests.uvc_emulator`.

The daemon is intended for integration testing on Linux systems where the
``dummy_hcd`` module and FunctionFS are available.  It forwards all USB control
requests to :class:`tests.uvc_emulator.UvcEmulatorLogic` and feeds streaming
endpoints with synthetic video packets generated by the emulator.

The script is deliberately conservative: it only aims to support the subset of
UVC requests exercised by the test-suite.  It is not meant to be a production
quality gadget implementation.
"""

from __future__ import annotations

import argparse
import logging
import os
import selectors
import signal
import struct
import sys
import threading
import time
from pathlib import Path
from typing import Optional, Sequence

from .uvc_emulator import (
    UvcEmulatorLogic,
    VS_PROBE_CONTROL,
    VS_COMMIT_CONTROL,
    VS_STILL_PROBE_CONTROL,
    VS_STILL_COMMIT_CONTROL,
    VS_STILL_IMAGE_TRIGGER_CONTROL,
)

LOG = logging.getLogger("uvc_gadget")

# functionfs event constants (see <linux/usb/functionfs.h>)
FUNCTIONFS_BIND = 0
FUNCTIONFS_UNBIND = 1
FUNCTIONFS_ENABLE = 2
FUNCTIONFS_DISABLE = 3
FUNCTIONFS_SETUP = 4

_EVENT_STRUCT = struct.Struct("<II")
_CTRL_STRUCT = struct.Struct("<BBHHH")
_EVENT_SIZE = _EVENT_STRUCT.size + _CTRL_STRUCT.size


class GadgetDaemon:
    """Simple FunctionFS daemon backed by :class:`UvcEmulatorLogic`."""

    def __init__(self, profile_path: Path, mountpoint: Path) -> None:
        self._emulator = UvcEmulatorLogic(profile_path)
        self._mountpoint = mountpoint
        self._ep0_fd: Optional[int] = None
        self._stream_fd: Optional[int] = None
        self._stop_event = threading.Event()
        self._selector = selectors.DefaultSelector()
        self._stream_thread: Optional[threading.Thread] = None

    # ------------------------------------------------------------------
    # Lifecycle
    # ------------------------------------------------------------------

    def start(self) -> None:
        self._open_control_endpoint()
        self._load_functionfs_descriptors()
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
        LOG.info("FunctionFS gadget running (mount=%s)", self._mountpoint)
        try:
            while not self._stop_event.is_set():
                events = self._selector.select(timeout=0.5)
                for key, _ in events:
                    if key.fd == self._ep0_fd:
                        self._handle_ep0_event()
        finally:
            self._teardown()

    def _open_control_endpoint(self) -> None:
        ep0_path = self._mountpoint / "ep0"
        self._ep0_fd = os.open(ep0_path, os.O_RDWR | os.O_CLOEXEC)
        self._selector.register(self._ep0_fd, selectors.EVENT_READ)

    def _load_functionfs_descriptors(self) -> None:
        if self._emulator.functionfs_descriptors:
            data = self._emulator.functionfs_descriptors.read_bytes()
            os.write(self._ep0_fd, data)
            LOG.debug("Wrote %d bytes of descriptors", len(data))
        if self._emulator.functionfs_strings:
            data = self._emulator.functionfs_strings.read_bytes()
            os.write(self._ep0_fd, data)
            LOG.debug("Wrote %d bytes of string descriptors", len(data))

    # ------------------------------------------------------------------
    # Event handling
    # ------------------------------------------------------------------

    def _handle_ep0_event(self) -> None:
        raw = os.read(self._ep0_fd, _EVENT_SIZE)
        if len(raw) != _EVENT_SIZE:
            LOG.warning("Short read on ep0: %d bytes", len(raw))
            return
        event_type, ep_num = _EVENT_STRUCT.unpack(raw[: _EVENT_STRUCT.size])
        ctrl_data = raw[_EVENT_STRUCT.size :]
        if event_type == FUNCTIONFS_SETUP:
            setup = _CTRL_STRUCT.unpack(ctrl_data)
            self._handle_setup(ep_num, *setup)
        elif event_type == FUNCTIONFS_ENABLE:
            LOG.info("Endpoint %d enabled", ep_num)
            self._open_streaming_endpoint(ep_num)
        elif event_type == FUNCTIONFS_DISABLE:
            LOG.info("Endpoint %d disabled", ep_num)
            self._close_streaming_endpoint()
        elif event_type in (FUNCTIONFS_BIND, FUNCTIONFS_UNBIND):
            LOG.debug("FunctionFS event: %s", "BIND" if event_type == 0 else "UNBIND")

    def _handle_setup(
        self,
        endpoint: int,
        bmRequestType: int,
        bRequest: int,
        wValue: int,
        wIndex: int,
        wLength: int,
    ) -> None:
        direction_in = bool(bmRequestType & 0x80)
        if not direction_in and wLength:
            payload = os.read(self._ep0_fd, wLength)
            self._emulator.handle_ctrl_transfer(
                bmRequestType,
                bRequest,
                wValue,
                wIndex,
                payload,
            )
            os.write(self._ep0_fd, b"\x00")  # status stage
            return

        response = self._emulator.handle_ctrl_transfer(
            bmRequestType,
            bRequest,
            wValue,
            wIndex,
            wLength,
        ) or b"\x00" * wLength
        os.write(self._ep0_fd, response[:wLength])

        selector = (wValue >> 8) & 0xFF
        if selector in {
            VS_PROBE_CONTROL,
            VS_COMMIT_CONTROL,
            VS_STILL_PROBE_CONTROL,
            VS_STILL_COMMIT_CONTROL,
            VS_STILL_IMAGE_TRIGGER_CONTROL,
        }:
            LOG.debug(
                "Handled VS control selector=0x%02x request=0x%02x", selector, bRequest
            )

    # ------------------------------------------------------------------
    # Streaming loop
    # ------------------------------------------------------------------

    def _open_streaming_endpoint(self, endpoint_number: int) -> None:
        if self._stream_fd is not None:
            return
        ep_path = self._mountpoint / f"ep{endpoint_number}"
        try:
            self._stream_fd = os.open(ep_path, os.O_RDWR | os.O_NONBLOCK | os.O_CLOEXEC)
        except FileNotFoundError:
            LOG.error("Streaming endpoint %s not available", ep_path)
            return
        self._stream_thread = threading.Thread(target=self._stream_loop, daemon=True)
        self._stream_thread.start()

    def _stream_loop(self) -> None:
        assert self._stream_fd is not None
        interval = 0.1
        while not self._stop_event.is_set():
            packet = self._emulator.get_next_video_packet()
            try:
                os.write(self._stream_fd, packet)
            except BlockingIOError:
                time.sleep(interval)
                continue
            time.sleep(interval)

    def _close_streaming_endpoint(self) -> None:
        if self._stream_fd is not None:
            os.close(self._stream_fd)
            self._stream_fd = None
        if self._stream_thread:
            self._stop_event.set()
            self._stream_thread.join(timeout=1)
            self._stop_event.clear()
            self._stream_thread = None

    # ------------------------------------------------------------------
    # Cleanup and signal handling
    # ------------------------------------------------------------------

    def _signal_handler(self, *_args) -> None:
        LOG.info("Termination requested")
        self._stop_event.set()

    def _teardown(self) -> None:
        self._close_streaming_endpoint()
        if self._ep0_fd is not None:
            self._selector.unregister(self._ep0_fd)
            os.close(self._ep0_fd)
            self._ep0_fd = None


def parse_args(argv: Optional[Sequence[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="User-space UVC gadget daemon")
    parser.add_argument(
        "profile",
        type=Path,
        help="Path to the camera profile JSON",
    )
    parser.add_argument(
        "--mountpoint",
        type=Path,
        default=Path("/dev/ffs/uvc"),
        help="FunctionFS mount point",
    )
    parser.add_argument(
        "--log-level",
        default="INFO",
        help="Logging verbosity",
    )
    return parser.parse_args(argv)


def main(argv: Optional[Sequence[str]] = None) -> int:
    args = parse_args(argv)
    logging.basicConfig(level=getattr(logging, args.log_level.upper(), logging.INFO))
    daemon = GadgetDaemon(args.profile, args.mountpoint)
    daemon.start()
    return 0


if __name__ == "__main__":  # pragma: no cover - manual execution only
    sys.exit(main())
